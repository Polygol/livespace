<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Livespace</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,700,1,0" />
    <script src="/assets/gurapp/api/gurasuraisu-api.js"></script>
    <script src="fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--background-color-tr);
            color: var(--text-color);
            width: 100vw; height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s;
            user-select: none;
        }

        /* SVG Filter */
        svg { display: none; }

        /* General UI Components */
        .icon-btn {
            background-color: transparent;
            border: none;
            color: var(--text-color);
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }
        .icon-btn.active {
            background-color: var(--accent);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            color: var(--background-color);
            border: 1px solid var(--glass-border);
            box-shadow: var(--sun-shadow);
        }
        .side-panel-btn {
            background-color: var(--search-background);
            border: 1px solid var(--glass-border);
            aspect-ratio: 1 / 1;
            border-radius: 50px;
            corner-shape: round;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            color: var(--text-color);
            box-shadow: var(--sun-shadow);
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }
        .material-symbols-rounded { font-size: 24px; }

        /* VIEWS */
        .view {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            transition: opacity 0.3s, transform 0.3s;
        }
        .view.hidden { opacity: 0; pointer-events: none; transform: scale(0.95); }

        /* --- HOME VIEW --- */
        #home-view { padding: 80px 20px 20px; overflow-y: auto; }
        
        .header-bar {
            position: fixed; top: 0; left: 0; right: 0;
            height: 80px; display: flex; align-items: center; gap: 15px;
            padding: 0 25px;
            z-index: 10;
            background-color: transparent;
        }
        .header-bar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            backdrop-filter: blur(2.5px);
            mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 50%, rgba(0, 0, 0, 0) 100%);
            -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 50%, rgba(0, 0, 0, 0) 100%);
        }
        .app-title { font-family: 'Open Runde', sans-serif; font-size: 1.5rem; font-weight: 700; }

        .spaces-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px; margin-top: 10px; padding-bottom: 100px;
        }

        .space-card {
            aspect-ratio: 1;
            box-shadow: var(--sun-shadow);
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            border-radius: 35px; corner-shape: superellipse(1.5);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            display: flex; flex-direction: column;
            padding: 15px;
            cursor: pointer;
            position: relative;
        }
        .space-card h3 { font-size: 1.1rem; margin-top: auto; word-break: break-word; }
        .space-card .meta { font-size: 0.8rem; opacity: 0.6; margin-top: 5px; }
        .space-delete {
            position: absolute; top: 10px; right: 10px;
            background: transparent; border: none; color: var(--text-color); opacity: 0.5;
        }

        /* --- WORKSPACE VIEW --- */
        #workspace-view { overflow: hidden; background-color: var(--background-mono); }
        
        #canvas-container { flex: 1; position: relative; width: 100%; height: 100%; overflow: hidden; cursor: crosshair; }
        
        /* Workspace Top Bar */
        .ws-top-bar {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; align-items: center;
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            padding: 8px 15px;
            border-radius: 50px;
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            z-index: 100;
            box-shadow: var(--sun-shadow), 0 4px 10px rgba(0,0,0,0.1);
        }
        
        .space-name { font-weight: 600; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* Floating Sidebar (Pages/Layers) */
        .side-panel {
            position: absolute; top: 80px; left: 20px; bottom: 100px;
            width: 60px;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none; z-index: 90;
        }
        .side-panel > * { pointer-events: auto; }
        
        .page-list-expanded {
            position: absolute; left: 70px; top: 0; width: 200px;
            background: var(--search-background); border: 1px solid var(--glass-border);
            border-radius: 25px; corner-shape: superellipse(1.5);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            padding: 10px;
            display: none;
            max-height: 300px; overflow-y: auto;
        }
        .page-list-expanded.show { display: block; }
        
        .page-item {
            padding: 8px 10px; border-radius: 12px; corner-shape: superellipse(1.5);
            margin-bottom: 5px; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            font-size: 0.9rem;
        }
        .page-item.active { background: var(--accent); color: var(--background-color); }

        /* Bottom toolssection */
        .toolssection {
            position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px;
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            padding: 10px 12px;
            border-radius: 35px; corner-shape: superellipse(1.5);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            z-index: 100;
            box-shadow: var(--sun-shadow), 0 5px 20px rgba(0,0,0,0.15);
        }

        /* Tool Options (Popovers) */
        .tool-options {
            position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%);
            background: var(--search-background); border: 1px solid var(--glass-border);
            padding: 10px; display: none; gap: 8px;
            border-radius: 35px 35px 0 0; corner-shape: superellipse(1.5);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            z-index: 99; flex-wrap: wrap; max-width: 90vw; justify-content: center;
        }
        .tool-options.show { display: flex; animation: slideUp 0.2s ease; }

        /* Properties Panel (Selection) */
        .prop-panel {
            position: absolute; bottom: 120px; right: 20px;
            background: var(--search-background); border: 1px solid var(--glass-border);
            border-radius: 15px; padding: 10px; display: none; flex-direction: column; gap: 8px;
            backdrop-filter: blur(10px); z-index: 90; width: 50px;
        }
        .prop-panel.show { display: flex; }
        
        @keyframes slideUp { from { transform: translate(-50%, 10px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }

        /* Color inputs */
        input[type="color"] { -webkit-appearance: none; width: 28px; height: 28px; border-radius: 50%; border: none; overflow: hidden; cursor: pointer; padding: 0; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid rgba(0,0,0,0.1); border-radius: 50%; }

        .new-btn-fab {
            position: fixed; bottom: 25px; right: 25px;
            background: var(--accent); color: var(--background-color);
            border-radius: 35px; corner-shape: superellipse(1.5);
            backdrop-filter: var(--edge-refraction-filter) saturate(2) blur(2.5px);
            width: 60px; height: 60px;
            display: flex; align-items: center; justify-content: center;
            border: 1px solid var(--glass-border);
            box-shadow: var(--sun-shadow), 0 5px 15px rgba(0,0,0,0.2); cursor: pointer; z-index: 50;
        }
    </style>
</head>
<body data-app-name="LIVESPACE">

    <!-- Glass Effect SVG -->
    <svg>
        <filter id="edge-refraction-only" color-interpolation-filters="sRGB">
            <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="2" result="turbulence"></feTurbulence>
            <feMorphology in="SourceGraphic" operator="erode" radius="4" result="eroded"></feMorphology>
            <feComposite in="SourceGraphic" in2="eroded" operator="out" result="border_mask"></feComposite>
            <feComposite in="turbulence" in2="border_mask" operator="in" result="edge_turbulence"></feComposite>
            <feDisplacementMap in="SourceGraphic" in2="edge_turbulence" scale="15" result="disp"></feDisplacementMap>
            <feBlend in="disp" in2="SourceGraphic" mode="lighten"></feBlend>
        </filter>
    </svg>

    <!-- Home View -->
    <div id="home-view" class="view">
        <div class="header-bar">
            <img src="favicon.png" style="height: 48px;">
            <div class="app-title">Livespace</div>
        </div>
        <div class="spaces-grid" id="spaces-list">
            <!-- Spaces generated here -->
        </div>
        <button class="new-btn-fab" onclick="createSpace()">
            <span class="material-symbols-rounded">add</span>
        </button>
    </div>

    <!-- Workspace View -->
    <div id="workspace-view" class="view hidden">
        <div id="canvas-container">
            <canvas id="c"></canvas>
        </div>

        <div class="ws-top-bar">
            <button class="icon-btn" onclick="exitWorkspace()" style="border-radius: 50%; width: 32px; height: 32px;">
                <span class="material-symbols-rounded" style="font-size: 20px;">arrow_back</span>
            </button>
            <div class="space-name" id="current-space-name" onclick="renameCurrentSpace()" style="cursor: pointer;">Untitled</div>
            <div style="width: 1px; height: 20px; background: var(--overlay-color-op); margin: 0 5px;"></div>
            <button class="icon-btn" onclick="exportPDF()" style="border-radius: 50%; width: 32px; height: 32px;" title="Export PDF">
                <span class="material-symbols-rounded" style="font-size: 20px;">arrow_circle_down</span>
            </button>
            <button class="icon-btn" onclick="undo()" style="border-radius: 50%; width: 32px; height: 32px;" title="Undo">
                <span class="material-symbols-rounded" style="font-size: 20px;">undo</span>
            </button>
            <button class="icon-btn" onclick="redo()" style="border-radius: 50%; width: 32px; height: 32px;" title="Redo">
                <span class="material-symbols-rounded" style="font-size: 20px;">redo</span>
            </button>
        </div>

        <div class="side-panel">
            <button class="side-panel-btn" id="pages-toggle">
                <span class="material-symbols-rounded">layers</span>
            </button>
            <!-- Expanded Pages List -->
            <div class="page-list-expanded" id="page-list-menu">
                <div style="display:flex; justify-content:space-between; margin-bottom:10px; font-weight:600;">
                    <span>Pages</span>
                    <span class="material-symbols-rounded" onclick="addPage()" style="cursor:pointer;">add</span>
                </div>
                <div id="pages-container"></div>
            </div>
            
            <button class="side-panel-btn" onclick="resetZoom()">
                <span class="material-symbols-rounded">center_focus_strong</span>
            </button>
        </div>

        <!-- Selection Properties (Contextual) -->
        <div class="prop-panel" id="prop-panel" style="width: auto; min-width: 60px;">
            <!-- Colors -->
            <div class="prop-row" style="display: flex; gap: 5px; justify-content: center;">
                <div title="Fill Color">
                    <input type="color" id="prop-fill" onchange="modifySelection('fill', this.value)">
                </div>
                <div title="Stroke Color" id="prop-stroke-container">
                    <input type="color" id="prop-stroke" onchange="modifySelection('stroke', this.value)">
                </div>
            </div>

            <!-- Font / Stroke Width -->
            <div class="prop-row" id="prop-extra-controls" style="display: flex; flex-direction: column; gap: 5px; margin-top: 5px;">
                 <input type="range" id="prop-stroke-width" min="0" max="20" title="Stroke Width" onchange="modifySelection('strokeWidth', this.value)">
                 <select id="prop-font" onchange="modifySelection('fontFamily', this.value)" style="font-size: 12px; width: 100%;">
                     <option value="Inter">Inter</option>
                     <option value="Open Runde">Open Runde</option>
                     <option value="Cursive">Handwritten</option>
                     <option value="Monospace">Mono</option>
                 </select>
                 <select id="prop-note-shape" onchange="modifySelection('noteShape', this.value)" style="display:none; font-size: 12px; width: 100%; margin-top: 5px;">
                     <option value="rect">Rectangle</option>
                     <option value="square">Square</option>
                     <option value="circle">Circle</option>
                 </select>
            </div>

            <div style="height: 1px; background: var(--border-color); margin: 5px 0;"></div>

            <!-- Actions -->
            <div class="prop-row" style="display: flex; gap: 5px; justify-content: center;">
                <button class="icon-btn" onclick="modifySelection('front')" title="Bring to Front" style="width:30px; height:30px; padding:0;">
                    <span class="material-symbols-rounded" style="font-size: 18px;">vertical_align_top</span>
                </button>
                <button class="icon-btn" onclick="modifySelection('back')" title="Send to Back" style="width:30px; height:30px; padding:0;">
                    <span class="material-symbols-rounded" style="font-size: 18px;">vertical_align_bottom</span>
                </button>
            </div>
            <button class="icon-btn" onclick="modifySelection('delete')" title="Delete" style="width:100%; height:30px; margin-top: 5px; color:#ff6b6b; justify-content: center;">
                <span class="material-symbols-rounded" style="font-size: 20px;">delete</span>
            </button>
        </div>

        <!-- Toolbar Options Popovers -->
        <div class="tool-options" id="draw-options">
            <input type="color" id="draw-color" value="#ffffff" title="Brush Color">
            <input type="range" id="draw-width" min="1" max="50" value="5" style="width: 100px;" title="Brush Size">
        </div>
        
        <div class="tool-options" id="line-options">
            <input type="color" id="line-color" value="#ffffff" title="Line Color">
            <input type="range" id="line-width" min="1" max="20" value="3" style="width: 100px;" title="Line Width">
        </div>

        <div class="tool-options" id="eraser-options">
            <input type="range" id="eraser-width" min="5" max="100" value="20" style="width: 100px;" title="Eraser Size">
        </div>

        <div class="tool-options" id="note-options">
            <select id="note-shape-default" style="padding: 5px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--glass-bg); color: var(--text-color);">
                <option value="rect">Rectangle</option>
                <option value="square">Square</option>
                <option value="circle">Circle</option>
            </select>
            <input type="color" id="note-color-default" value="#ffeb3b" title="Note Color">
        </div>

        <div class="tool-options" id="shape-options">
            <select id="shape-type" style="padding: 5px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--glass-bg); color: var(--text-color);">
                <option value="rect">Rectangle</option>
                <option value="circle">Circle</option>
                <option value="triangle">Triangle</option>
                <option value="pentagon">Pentagon</option>
                <option value="octagon">Octagon</option>
            </select>
            <div style="display:flex; flex-direction:column; gap:2px; align-items:center;">
                <label style="font-size:10px;">Fill</label>
                <input type="color" id="shape-fill" value="#333333">
            </div>
            <div style="display:flex; flex-direction:column; gap:2px; align-items:center;">
                <label style="font-size:10px;">Stroke</label>
                <input type="color" id="shape-stroke" value="#ffffff">
            </div>
            <input type="range" id="shape-stroke-width" min="0" max="20" value="2" style="width: 80px;" title="Stroke Width">
        </div>

        <!-- Main toolssection -->
        <div class="toolssection">
            <button class="icon-btn active" onclick="setMode('select')" id="btn-select" title="Select">
                <span class="material-symbols-rounded">arrow_selector_tool</span>
            </button>
            <button class="icon-btn" onclick="setMode('draw')" id="btn-draw" oncontextmenu="toggleOptions('draw-options'); return false;" title="Draw">
                <span class="material-symbols-rounded">ink_pen</span>
            </button>
            <button class="icon-btn" onclick="setMode('eraser')" id="btn-eraser" oncontextmenu="toggleOptions('eraser-options'); return false;" title="Eraser">
                <span class="material-symbols-rounded">ink_eraser</span>
            </button>
            <button class="icon-btn" onclick="setMode('line')" id="btn-line" oncontextmenu="toggleOptions('line-options'); return false;" title="Line">
                <span class="material-symbols-rounded">horizontal_rule</span>
            </button>
            <button class="icon-btn" onclick="setMode('shape')" id="btn-shape" oncontextmenu="toggleOptions('shape-options'); return false;" title="Shapes">
                <span class="material-symbols-rounded">shapes</span>
            </button>
            <div style="width: 1px;background: var(--overlay-color-op);margin: 5px;"></div>
            <button class="icon-btn" onclick="setMode('note')" id="btn-note" title="Sticky Note">
                <span class="material-symbols-rounded">sticky_note_2</span>
            </button>
            <button class="icon-btn" onclick="addText()" id="btn-text" title="Text">
                <span class="material-symbols-rounded">text_fields</span>
            </button>
            <button class="icon-btn" onclick="importImage()" id="btn-img" title="Image">
                <span class="material-symbols-rounded">image</span>
            </button>
             <button class="icon-btn" onclick="toggleGrid()" id="btn-grid" title="Grid">
                <span class="material-symbols-rounded">grid_3x3</span>
            </button>
        </div>
    </div>

    <script>
        // --- Database Setup (Dexie) ---
        const db = new Dexie('LivespaceDB');
        db.version(1).stores({
            spaces: '++id, title, createdAt, thumbnail',
            pages: '++id, spaceId, title, order, data'
        });

        // --- Global State ---
        let currentSpaceId = null;
        let currentPageId = null;
        let canvas;
        let mode = 'select';
        let isGridEnabled = true;
        let stickyColor = '#ffeb3b';
        let currentPages = [];
        
        // History State
        let history = [];
        let historyIndex = -1;
        let historyProcessing = false;

        // --- Fabric Initialization ---
        function initCanvas() {
            canvas = new fabric.Canvas('c', {
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 'transparent',
                isDrawingMode: false,
                fireRightClick: false, // Disable right click for touch focus
                stopContextMenu: true
            });

            // Prevent browser context menu globally
            window.addEventListener('contextmenu', e => e.preventDefault(), { passive: false });
            
            // History Listeners
            canvas.on('object:added', (e) => saveHistory());
            canvas.on('object:modified', (e) => saveHistory());
            canvas.on('object:removed', (e) => saveHistory());
            
            // Sticky Note Double Click Edit
            canvas.on('mouse:dblclick', function(opt) {
                if (opt.target && opt.target.isStickyNote) {
                    const group = opt.target;
                    const noteShape = group.noteShape;
                    
                    // Temporarily ungroup to allow text editing
                    const sel = group.toActiveSelection();
                    canvas.discardActiveObject();
                    
                    const items = sel.getObjects();
                    const textObj = items.find(i => i.type === 'i-text');
                    const bgObj = items.find(i => i !== textObj);
                    
                    if (textObj) {
                        canvas.setActiveObject(textObj);
                        textObj.enterEditing();
                        textObj.selectAll();
                        
                        textObj.on('editing:exited', () => {
                             // Regroup after editing
                             const newGroup = new fabric.Group([bgObj, textObj]);
                             newGroup.isStickyNote = true;
                             newGroup.noteShape = noteShape;
                             
                             canvas.remove(bgObj);
                             canvas.remove(textObj);
                             canvas.add(newGroup);
                             canvas.requestRenderAll();
                             saveHistory();
                             textObj.off('editing:exited');
                        });
                    }
                    canvas.requestRenderAll();
                }
            });
            
            // Touch Gesture Logic (Infinite Pan/Zoom)
            canvas.on('mouse:wheel', function(opt) {
                var delta = opt.e.deltaY;
                var zoom = canvas.getZoom();
                zoom *= 0.999 ** delta;
                if (zoom > 20) zoom = 20;
                if (zoom < 0.01) zoom = 0.01;
                canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
                opt.e.preventDefault();
                opt.e.stopPropagation();
                updateGrid();
            });

            // Input Handling (Pan, Line Tool, Shape Draw)
            let isDragging = false;
            let isDrawingShape = false;
            let shapeObj = null;
            let lastPosX, lastPosY;

            canvas.on('mouse:down', function(opt) {
                var evt = opt.e;
                const ptr = canvas.getPointer(evt);

                // Line Tool Logic
                if (mode === 'line') {
                    isDrawingShape = true;
                    const points = [ptr.x, ptr.y, ptr.x, ptr.y];
                    shapeObj = new fabric.Line(points, {
                        strokeWidth: parseInt(document.getElementById('line-width').value),
                        stroke: document.getElementById('line-color').value,
                        originX: 'center', originY: 'center'
                    });
                    canvas.add(shapeObj);
                    canvas.requestRenderAll();
                    return;
                }

                // Shape Tool Logic
                if (mode === 'shape') {
                     createShapeAt(ptr.x, ptr.y);
                     setMode('select');
                     return;
                }

                // Sticky Note Tool Logic
                if (mode === 'note') {
                    createStickyNoteAt(ptr.x, ptr.y);
                    setMode('select');
                    return;
                }

                // Pan Logic
                if (opt.target && !isAltDown(evt) && !canvas.isDrawingMode) return; 
                if (isAltDown(evt) || (!opt.target && !canvas.isDrawingMode)) {
                    isDragging = true;
                    canvas.selection = false;
                    lastPosX = evt.clientX || evt.touches[0].clientX;
                    lastPosY = evt.clientY || evt.touches[0].clientY;
                }
            });

            canvas.on('mouse:move', function(opt) {
                const ptr = canvas.getPointer(opt.e);
                
                if (isDrawingShape && mode === 'line') {
                    shapeObj.set({ x2: ptr.x, y2: ptr.y });
                    canvas.requestRenderAll();
                    return;
                }

                if (isDragging) {
                    var e = opt.e;
                    var clientX = e.clientX || e.touches[0].clientX;
                    var clientY = e.clientY || e.touches[0].clientY;
                    var vpt = canvas.viewportTransform;
                    vpt[4] += clientX - lastPosX;
                    vpt[5] += clientY - lastPosY;
                    canvas.requestRenderAll();
                    lastPosX = clientX;
                    lastPosY = clientY;
                    updateGrid();
                }
            });

            canvas.on('mouse:up', function() {
                if (isDrawingShape) {
                    isDrawingShape = false;
                    shapeObj.setCoords();
                    saveHistory();
                }
                
                canvas.setViewportTransform(canvas.viewportTransform);
                isDragging = false;
                canvas.selection = true;
            });

            canvas.on('selection:created', showProps);
            canvas.on('selection:updated', showProps);
            canvas.on('selection:cleared', hideProps);
            
            window.addEventListener('resize', () => {
                canvas.setWidth(window.innerWidth);
                canvas.setHeight(window.innerHeight);
            });

            updateGrid();
        }

        // --- History System ---
        function saveHistory() {
            if (historyProcessing) return;
            // Limit history
            if (history.length > 10) history.shift();
            // Remove redo steps if we do something new
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }
            history.push(JSON.stringify(canvas.toDatalessJSON()));
            historyIndex = history.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyProcessing = true;
                historyIndex--;
                canvas.clear();
                canvas.loadFromJSON(JSON.parse(history[historyIndex]), () => {
                    canvas.renderAll();
                    historyProcessing = false;
                });
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyProcessing = true;
                historyIndex++;
                canvas.clear();
                canvas.loadFromJSON(JSON.parse(history[historyIndex]), () => {
                    canvas.renderAll();
                    historyProcessing = false;
                });
            }
        }

        function isAltDown(evt) { return evt.altKey || (evt.touches && evt.touches.length === 2); }

        // Grid Background Logic
        function updateGrid() {
            if (!isGridEnabled) {
                document.getElementById('canvas-container').style.background = 'transparent';
                return;
            }
            // CSS Radial Gradient Dots - cheap way to simulate infinite grid
            const zoom = canvas ? canvas.getZoom() : 1;
            const size = 20 * zoom;
            const vpt = canvas ? canvas.viewportTransform : [1,0,0,1,0,0];
            const offX = vpt[4];
            const offY = vpt[5];
                        
            document.getElementById('canvas-container').style.backgroundSize = `${size}px ${size}px`;
            document.getElementById('canvas-container').style.backgroundPosition = `${offX}px ${offY}px`;
            document.getElementById('canvas-container').style.backgroundImage = 
                `radial-gradient(circle, var(--overlay-color-op) 1px, transparent 1px)`;
        }

        function toggleGrid() {
            isGridEnabled = !isGridEnabled;
            updateGrid();
        }

        function resetZoom() {
            canvas.setViewportTransform([1,0,0,1,0,0]);
            updateGrid();
        }
        
        // --- Tools & Modes ---
        function setMode(newMode) {
            // Toggle options if clicking active mode
            if (mode === newMode) {
                const map = {
                    'draw': 'draw-options',
                    'eraser': 'eraser-options',
                    'line': 'line-options',
                    'shape': 'shape-options',
                    'note': 'note-options'
                };
                if (map[newMode]) {
                    toggleOptions(map[newMode]);
                    return;
                }
            }

            mode = newMode;
            canvas.isDrawingMode = false;
            
            document.querySelectorAll('.toolssection .icon-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn-' + newMode);
            if(btn) btn.classList.add('active');
            
            // Hide all options first
            document.querySelectorAll('.tool-options').forEach(o => o.classList.remove('show'));

            if (mode === 'draw') {
                canvas.isDrawingMode = true;
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                updateDrawSettings();
            } else if (mode === 'eraser') {
                 canvas.isDrawingMode = true;
                 canvas.freeDrawingBrush = new fabric.EraserBrush(canvas);
                 canvas.freeDrawingBrush.width = parseInt(document.getElementById('eraser-width').value, 10);
            } else if (mode === 'line') {
                 canvas.selection = false;
            }
            
            // Show options for the mode automatically if switching to it
            /* Optional: To keep UI clean, we can choose NOT to show immediately, or show. 
               Let's show them to replace the right-click behavior. */
            const map = {
                'draw': 'draw-options',
                'eraser': 'eraser-options',
                'line': 'line-options',
                'shape': 'shape-options',
                'note': 'note-options'
            };
            if (map[mode]) {
                document.getElementById(map[mode]).classList.add('show');
            }
        }

        // --- Shapes ---
        function createShapeAt(x, y) {
            const type = document.getElementById('shape-type').value;
            const fill = document.getElementById('shape-fill').value;
            const stroke = document.getElementById('shape-stroke').value;
            const strokeWidth = parseInt(document.getElementById('shape-stroke-width').value);
            
            let shape;
            const opts = { left: x, top: y, fill: fill, stroke: stroke, strokeWidth: strokeWidth, originX: 'center', originY: 'center' };
            
            if (type === 'rect') shape = new fabric.Rect({ ...opts, width: 100, height: 100 });
            else if (type === 'circle') shape = new fabric.Circle({ ...opts, radius: 50 });
            else if (type === 'triangle') shape = new fabric.Triangle({ ...opts, width: 100, height: 100 });
            else if (type === 'pentagon') shape = new fabric.Polygon([
                {x: 50, y: 0}, {x: 98, y: 35}, {x: 79, y: 90}, {x: 21, y: 90}, {x: 2, y: 35}
            ], opts);
            else if (type === 'octagon') shape = new fabric.Polygon([
                {x:30,y:0}, {x:70,y:0}, {x:100,y:30}, {x:100,y:70}, {x:70,y:100}, {x:30,y:100}, {x:0,y:70}, {x:0,y:30}
            ], opts);
            
            canvas.add(shape);
            canvas.setActiveObject(shape);
            saveHistory();
        }

        // --- Sticky Notes ---
        function createStickyNoteAt(x, y) {
            const shapeType = document.getElementById('note-shape-default').value;
            const color = document.getElementById('note-color-default').value;
            
            let bg;
            if (shapeType === 'circle') {
                bg = new fabric.Circle({ radius: 75, fill: color, originX: 'center', originY: 'center' });
            } else if (shapeType === 'square') {
                bg = new fabric.Rect({ width: 150, height: 150, fill: color, originX: 'center', originY: 'center', rx: 5, ry: 5 });
            } else {
                bg = new fabric.Rect({ width: 200, height: 150, fill: color, originX: 'center', originY: 'center', rx: 5, ry: 5 });
            }
            
            const text = new fabric.IText('Note', {
                fontFamily: 'Inter',
                fontSize: 20,
                fill: (color === '#212121' || color === '#000000') ? '#fff' : '#333',
                originX: 'center', originY: 'center',
                width: 130,
                splitByGrapheme: true
            });
            
            const group = new fabric.Group([bg, text], { left: x, top: y });
            group.isStickyNote = true;
            group.noteShape = shapeType;
            
            canvas.add(group);
            canvas.setActiveObject(group);
            saveHistory();
        }

        function addText() {
            setMode('select');
            const vpt = canvas.viewportTransform;
            const x = (-vpt[4] + canvas.width/2) / canvas.getZoom();
            const y = (-vpt[5] + canvas.height/2) / canvas.getZoom();
            
            const text = new fabric.IText('Type here', {
                left: x, top: y,
                fontFamily: 'Inter', fontSize: 24,
                fill: document.body.classList.contains('light-theme') ? '#000' : '#fff'
            });
            canvas.add(text);
            canvas.setActiveObject(text);
            saveHistory();
        }
        
        // --- Draw Settings ---
        document.getElementById('draw-color').addEventListener('change', updateDrawSettings);
        document.getElementById('draw-width').addEventListener('input', updateDrawSettings);
        document.getElementById('eraser-width').addEventListener('input', function() {
            if (mode === 'eraser' && canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.width = parseInt(this.value, 10);
            }
        });

        function updateDrawSettings() {
            if(mode === 'draw' && canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = document.getElementById('draw-color').value;
                canvas.freeDrawingBrush.width = parseInt(document.getElementById('draw-width').value, 10);
            }
        }

        function toggleOptions(id) {
            const el = document.getElementById(id);
            if(el.classList.contains('show')) el.classList.remove('show');
            else {
                 document.querySelectorAll('.tool-options').forEach(o => o.classList.remove('show'));
                 el.classList.add('show');
            }
        }

        // --- Image Import ---
        function importImage() {
            Gurasuraisu.requestFile({ accept: 'image/*', multiple: false }).then(files => {
                if (files && files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(f) {
                        fabric.Image.fromURL(f.target.result, function(img) {
                            img.scaleToWidth(200);
                            canvas.add(img);
                            canvas.setActiveObject(img);
                            canvas.renderAll();
                            saveCurrentPage(true); // Auto-save after import
                        });
                    };
                    reader.readAsDataURL(files[0]);
                }
            });
        }
        
        // --- Properties & Modifications ---
        function showProps() {
            const active = canvas.getActiveObject();
            if (!active) return;
            document.getElementById('prop-panel').classList.add('show');
            
            const fillParent = document.getElementById('prop-fill').parentElement;
            const strokeParent = document.getElementById('prop-stroke-container');
            const strokeWidth = document.getElementById('prop-stroke-width');
            const fontSelect = document.getElementById('prop-font');
            const noteShape = document.getElementById('prop-note-shape');
            
            // Reset Display
            fillParent.style.display = 'none';
            strokeParent.style.display = 'none';
            strokeWidth.style.display = 'none';
            fontSelect.style.display = 'none';
            noteShape.style.display = 'none';

            if (active.isStickyNote) {
                // Sticky Note
                fillParent.style.display = 'block';
                document.getElementById('prop-fill').value = active.item(0).fill;
                
                fontSelect.style.display = 'block';
                fontSelect.value = active.item(1).fontFamily;
                
                noteShape.style.display = 'block';
                noteShape.value = active.noteShape || 'rect';
            } else if (active.type === 'i-text') {
                // Text
                fillParent.style.display = 'block';
                document.getElementById('prop-fill').value = active.fill;
                
                strokeParent.style.display = 'block';
                document.getElementById('prop-stroke').value = active.stroke || '#000000';
                
                strokeWidth.style.display = 'block';
                strokeWidth.value = active.strokeWidth || 0;
                
                fontSelect.style.display = 'block';
                fontSelect.value = active.fontFamily;
            } else if (active.type === 'image') {
                // Image - only Actions
            } else if (active.type === 'path' || active.type === 'line') {
                // Drawing / Line
                strokeParent.style.display = 'block';
                document.getElementById('prop-stroke').value = active.stroke;
                
                strokeWidth.style.display = 'block';
                strokeWidth.value = active.strokeWidth || 0;
            } else {
                // Shapes (Rect, Circle, etc.)
                if (active.fill && active.fill !== 'transparent') {
                    fillParent.style.display = 'block';
                    document.getElementById('prop-fill').value = active.fill;
                }
                
                strokeParent.style.display = 'block';
                document.getElementById('prop-stroke').value = active.stroke || '#000000';
                
                strokeWidth.style.display = 'block';
                strokeWidth.value = active.strokeWidth || 0;
            }
        }
        
        function hideProps() { document.getElementById('prop-panel').classList.remove('show'); }

        function modifySelection(attr, val) {
            const active = canvas.getActiveObject();
            if (!active) return;
            
            if (attr === 'delete') {
                canvas.remove(active);
                hideProps();
            } else if (attr === 'noteShape') {
                if (active.isStickyNote) {
                    const textObj = active.item(1);
                    const oldBg = active.item(0);
                    const color = oldBg.fill;
                    
                    let newBg;
                    if (val === 'circle') newBg = new fabric.Circle({ radius: 75, fill: color, originX: 'center', originY: 'center' });
                    else if (val === 'square') newBg = new fabric.Rect({ width: 150, height: 150, fill: color, originX: 'center', originY: 'center', rx: 5, ry: 5 });
                    else newBg = new fabric.Rect({ width: 200, height: 150, fill: color, originX: 'center', originY: 'center', rx: 5, ry: 5 });
                    
                    // Recreate group to ensure bounding box updates correctly
                    const x = active.left;
                    const y = active.top;
                    
                    canvas.remove(active);
                    const newGroup = new fabric.Group([newBg, textObj], { left: x, top: y });
                    newGroup.isStickyNote = true;
                    newGroup.noteShape = val;
                    
                    canvas.add(newGroup);
                    canvas.setActiveObject(newGroup);
                }
            } else if (attr === 'front') {
                active.bringToFront();
            } else if (attr === 'back') {
                active.sendToBack();
            } else if (attr === 'fill') {
                if (active.isStickyNote) active.item(0).set('fill', val);
                else active.set('fill', val);
            } else if (attr === 'stroke') {
                active.set('stroke', val);
            } else if (attr === 'strokeWidth') {
                active.set('strokeWidth', parseInt(val));
            } else if (attr === 'fontFamily') {
                if (active.isStickyNote) active.item(1).set('fontFamily', val);
                else if (active.type === 'i-text') active.set('fontFamily', val);
            }
            
            canvas.requestRenderAll();
            saveHistory();
        }
        
        async function deletePage(id, e) {
            if (e) e.stopPropagation();
            if (await Gurasuraisu.showConfirm("Delete this page?")) {
                await db.pages.delete(id);
                loadPages(currentSpaceId);
                // If current page deleted, load another
                if (id === currentPageId) {
                    const remaining = await db.pages.where('spaceId').equals(currentSpaceId).toArray();
                    if (remaining.length > 0) switchToPage(remaining[0].id);
                    else addPage(); // Always have one
                }
            }
        }

        // --- View Navigation & Space Management ---
        
        async function loadHome() {
            document.getElementById('workspace-view').classList.add('hidden');
            document.getElementById('home-view').classList.remove('hidden');
            const spaces = await db.spaces.toArray();
            const container = document.getElementById('spaces-list');
            container.innerHTML = '';
            spaces.forEach(space => {
                const el = document.createElement('div');
                el.className = 'space-card';
                el.onclick = (e) => { if(e.target.tagName !== 'BUTTON') openSpace(space.id, space.title); };
                el.innerHTML = `
                    <h3>${space.title}</h3>
                    <div class="meta">${new Date(space.createdAt).toLocaleDateString()}</div>
                    <button class="space-delete" onclick="deleteSpace(${space.id}, '${space.title.replace(/'/g, "\\'")}', event)"><span class="material-symbols-rounded" style="padding: 5px; font-size: 18px;">cancel</span></button>
                `;
                container.appendChild(el);
            });
        }

        async function createSpace() {
            const id = await db.spaces.add({ title: 'New Space', createdAt: Date.now() });
            // Create default page
            await db.pages.add({ spaceId: id, title: 'Page 1', order: 0, data: {} });
            loadHome();
        }
        
        async function deleteSpace(id, title, e) {
            if (e) e.stopPropagation();
            const confirmed = await Gurasuraisu.showConfirm(`Are you sure you want to delete "${title}" and all its pages?`);
            if (confirmed) {
                await db.spaces.delete(id);
                await db.pages.where('spaceId').equals(id).delete();
                loadHome();
            }
        }
        
        async function renameCurrentSpace() {
            const space = await db.spaces.get(currentSpaceId);
            const newName = await Gurasuraisu.showPrompt("Enter new name for this space:", "Rename Space", space.title);
            if (newName && newName.trim() !== "") {
                await db.spaces.update(currentSpaceId, { title: newName.trim() });
                document.getElementById('current-space-name').innerText = newName.trim();
            }
        }        
        
        async function openSpace(id, title) {
            currentSpaceId = id;
            currentPageId = null; 
            document.getElementById('current-space-name').innerText = title;
            document.getElementById('home-view').classList.add('hidden');
            const ws = document.getElementById('workspace-view');
            ws.classList.remove('hidden');
            
            if (!canvas) initCanvas();
            else { canvas.clear(); resetZoom(); } // Reset for new space
            
            await loadPages(id);
        }

        function exitWorkspace() {
            saveCurrentPage().then(loadHome);
        }
        
        function exportPDF() {
            if (!window.jspdf) {
                Gurasuraisu.showAlert('Ensure you are connected to the internet.', 'Error');
                return;
            }
            
            // Calculate Bounding Box of all content
            const objects = canvas.getObjects();
            if (objects.length === 0) {
                Gurasuraisu.showPopup('Canvas is empty');
                return;
            }
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            objects.forEach(o => {
                const br = o.getBoundingRect(); // accounts for rotation and scale
                if (br.left < minX) minX = br.left;
                if (br.top < minY) minY = br.top;
                if (br.left + br.width > maxX) maxX = br.left + br.width;
                if (br.top + br.height > maxY) maxY = br.top + br.height;
            });
            
            // Add padding
            const padding = 50;
            const x = minX - padding;
            const y = minY - padding;
            const w = maxX - minX + (padding * 2);
            const h = maxY - minY + (padding * 2);
            
            // White Background for PDF
            const originalBg = canvas.backgroundColor;
            canvas.backgroundColor = '#ffffff';
            
            // Generate Image
            const data = canvas.toDataURL({
                format: 'jpeg',
                quality: 0.9,
                multiplier: 2, // High Quality
                left: x,
                top: y,
                width: w,
                height: h
            });
            
            canvas.backgroundColor = originalBg; // Restore transparent
            canvas.renderAll();
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: w > h ? 'landscape' : 'portrait',
                unit: 'px',
                format: [w, h]
            });
            
            doc.addImage(data, 'JPEG', 0, 0, w, h);
            doc.save((document.getElementById('current-space-name').innerText || 'drawing') + '.pdf');
        }

        // --- Page Logic ---
        async function loadPages(spaceId) {
            currentPages = await db.pages.where('spaceId').equals(spaceId).sortBy('order');
            const listEl = document.getElementById('pages-container');
            listEl.innerHTML = '';
            
            currentPages.forEach((p, index) => {
                const row = document.createElement('div');
                row.className = `page-item ${index===0 ? 'active' : ''}`;
                row.innerHTML = `
                    <span onclick="switchToPage(${p.id})" style="flex-grow:1; overflow:hidden; text-overflow:ellipsis;">${p.title}</span>
                    <span class="material-symbols-rounded" onclick="deletePage(${p.id}, event)" style="font-size:16px; opacity:0.5; cursor:pointer;">cancel</span>
                `;
                listEl.appendChild(row);
            });
            
            // Open first page
            if (currentPages.length > 0) switchToPage(currentPages[0].id);
        }

        async function addPage() {
            const title = `Page ${currentPages.length + 1}`;
            const id = await db.pages.add({
                spaceId: currentSpaceId,
                title: title,
                order: currentPages.length,
                data: {}
            });
            loadPages(currentSpaceId); // Refresh list
            switchToPage(id);
        }

        async function saveCurrentPage(silent = false) {
            if (!currentPageId || !canvas) return;
            try {
                // Use toObject() for a cleaner data structure in IndexedDB
                const data = canvas.toObject();
                await db.pages.update(currentPageId, { data: data });
                if (!silent) Gurasuraisu.showPopup('Saved');
            } catch (err) {
                console.error("Save failed:", err);
            }
        }

        async function switchToPage(pageId) {
            if (currentPageId === pageId) return;
        
            if (currentPageId) {
                // Ensure previous page is saved before switching
                const prevData = canvas.toObject();
                await db.pages.update(currentPageId, { data: prevData });
            }
            
            currentPageId = pageId;
            
            // UI Update for active state
            const items = document.getElementById('pages-container').children;
            const pageArr = await db.pages.where('spaceId').equals(currentSpaceId).sortBy('order');
            Array.from(items).forEach((c, i) => {
                if (pageArr[i].id === pageId) c.classList.add('active');
                else c.classList.remove('active');
            });
            
            const page = await db.pages.get(pageId);
            if (page && page.data && page.data.objects) {
                // Clear canvas and load new data
                canvas.clear();
                canvas.loadFromJSON(page.data, () => {
                    canvas.renderAll();
                    resetZoom();
                });
            } else {
                canvas.clear();
                resetZoom();
            }
        }

        document.getElementById('pages-toggle').addEventListener('click', () => {
             document.getElementById('page-list-menu').classList.toggle('show');
        });

        // Initialize App
        loadHome();

    </script>
</body>
</html>
